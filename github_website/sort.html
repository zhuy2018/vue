<!DOCTYPE HTML>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>首页 - js五种排序：冒泡、快速、选择、插入、希尔排序</title>
<link href="css/basic.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="js/jquery-1.10.1.min.js"></script>
<script type="text/javascript" src="js/index_zong.js"></script>
<style type="text/css">
.index{width:720px;margin:0 auto;font: 14px/1.5 tahoma,arial,"Hiragino Sans GB",\5b8b\4f53;}
.index h2{font-size:32px;margin:0 0 20px;}
p{text-align: center;margin-top: 20px;}
.div1{width:60%;padding:0 0 30px;border-bottom:1px dotted #999;margin:0 auto 60px;}
.div1 h2{font-size:20px;font-family:"微软雅黑";margin:0 0 20px;line-height:160%;}
.div1 p{font-size:18px;text-align:justify;margin:0 0 20px;color:#06F;}
.div1 div:nth-child(3) p:last-child{color: #F30;}
.div1:last-child{ border:0 none;}
</style>
</head>

<body>
<div class="index">
  <h2>js五种排序：冒泡、快速、选择、插入、希尔排序</h2>
  
</div>

<div class="div1">
  <h2>1、冒泡排序<br />原理：数组相邻两项进行比较，如果前一项比后一项大则交换位置，比较arr.length-1轮,每一轮把最大的一位数放最后</h2>
  <div id="div1"></div>
  <div id="div2"></div>
  <script type="text/javascript">
    var arr = [2,88,6,8,3,0,34,72];
    var sort = {};
	var div1=document.getElementById('div1'),
		div2=document.getElementById('div2');
    sort.bubbleSort = function (arr) {
        if (arr.length <= 1) {
            return arr;
        }
        //i表示比较的轮数
        for (var i = 0; i < arr.length - 1; i++) {
            //比较i轮，把i个最大数放在数组后面，排数这i个数
            for (var j = 0; j < arr.length - 1 - i; j++) {
                if (arr[j] > arr[j + 1]) {
                    var temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                }
            }
			//console.log("第" + i + "轮:arr=[" + arr + "]");
            div1.innerHTML+=("<p>第" + i + "轮:arr=[" + arr + "]</p>");
        }
    };
    sort.bubbleSort(arr);
	//console.log(arr);
	div2.innerHTML+=("<p>" + arr + "</p>");
    第0轮:arr=[2,6,8,3,0,34,72,88]
    第1轮:arr=[2,6,3,0,8,34,72,88]
    第2轮:arr=[2,3,0,6,8,34,72,88]
    第3轮:arr=[2,0,3,6,8,34,72,88]
	第4轮:arr=[0,2,3,6,8,34,72,88]
	第5轮:arr=[0,2,3,6,8,34,72,88]
	第6轮:arr=[0,2,3,6,8,34,72,88]
	[0, 2, 3, 6, 8, 34, 72, 88]
  </script>
</div>

<div class="div1">
  <h2>2、快速排序<br />
     原理：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进<br />
     （1）在数据集之中，选择一个元素作为"基准"（pivot）。<br />
     （2）所有小于"基准"的元素，都移到"基准"的左边；所有大于"基准"的元素，都移到"基准"的右边。<br />
     （3）对"基准"左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。</h2>
  <div id="div3"></div>
  <div id="div4"></div>
  <script type="text/javascript">
	var arr = [2,88,6,8,3,0,34,72];
	var div3=document.getElementById('div3'),
		div4=document.getElementById('div4');
	var sort = {};
    sort.quickSort = function (arr) {
        if (arr.length <= 1) {
            return arr;
        }
        var base = [arr[0]];//选择的基准元素
        var leftSmall = [], rightBig = [];
        for (var i = 1; i < arr.length; i++) {
            if (arr[i] <= base[0]) {
                leftSmall.push(arr[i]);
            } else {
                rightBig.push(arr[i]);
            }
        }
        //console.log("leftSmall:[" + leftSmall + "]\nbase:" + base + "\nrightBig:[" + rightBig + "]");
		div3.innerHTML+=("<p>leftSmall:[" + leftSmall + "]<br/>\nbase:" + base + "<br/>\nrightBig:[" + rightBig + "]</p>");
        return sort.quickSort(leftSmall).concat(base, sort.quickSort(rightBig));
    }
	//console.log(sort.quickSort(arr));
	sort.quickSort(arr);
	div4.innerHTML+=("<p>" + arr + "</p>");
	leftSmall:[0]
	base:2
	rightBig:[88,6,8,3,34,72]
	[0,2,88,6,8,3,34,72]
	
	leftSmall:[6,8,3,34,72]
	base:88
	rightBig:[]
	[0,2,6,8,3,34,72,88]
	
	leftSmall:[3]
	base:6
	rightBig:[8,34,72]
	[0,2,3,6,8,34,72,88]

	leftSmall:[]
	base:8
	rightBig:[34,72]
	[0,2,3,6,8,34,72,88]
	
	leftSmall:[]
	base:34
	rightBig:[72]
	[0,2,3,6,8,34,72,88],
	[0, 2, 3, 6, 8, 34, 72,88]

  </script>
</div>

<div class="div1">
  <h2>3、选择排序<br />
   原理：每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。 选择排序是不稳定的排序方法
   假定数组每次比较范围内第一个元素最小min，和剩下的比较，如果比假定的这个元素小，则令min为这个元素，直到找到最小的，然后交换位置,每比较一次，
   就把最小的一位数找出来放数组最前面。</h2>
  <div id="div5"></div>
  <div id="div6"></div>
  <script type="text/javascript">
  	var arr = [2,88,6,8,3,0,34,72];
	var div5=document.getElementById('div5'),
		div6=document.getElementById('div6');
	var sort = {};
	sort.selectionSort = function (arr) {
        for (var i = 0; i < arr.length; i++) {
            var min = arr[i];//假定比较范围内第一个值为最小的
            var index = i;//记录最小值的下标
            for (var j = i + 1; j < arr.length; j++) {
                //找到比较范围内第一个值为最小的记录下来
                if (arr[j] < min) {
                    min = arr[j];
                    index = j;
                }
            }
            //把范围内最小的值交换到范围内第一个
            if (index != i) {
                var temp = arr[i];
                arr[i] = arr[index];
                arr[index] = temp;
            }
            //console.log(arr+"\n");
			div5.innerHTML+=("<p>"+ arr +"</p>");
        }
    }
	sort.selectionSort(arr);
	//console.log(arr);
	div6.innerHTML+=("<p>"+ arr +"</p>");
	
	0,88,6,8,3,2,34,72

	0,2,6,8,3,88,34,72

	0,2,3,8,6,88,34,72

	0,2,3,6,8,88,34,72

	0,2,3,6,8,88,34,72

	0,2,3,6,8,34,88,72

	0,2,3,6,8,34,72,88

	0,2,3,6,8,34,72,88
	[0, 2, 3, 6, 8, 34, 72, 88]

  </script>
</div>

<div class="div1">
  <h2>4、插入排序<br />
   插入算法把要排序的数组分成两部分：第一部分包含了这个数组的所有元素，但将最后一个元素除外（让数组多一个空间才有插入的位置），<br />
   而第二部分就只包含这一个元素（即待插入元素）。在第一部分排序完成后，再将这个最后元素插入到已排好序的第一部分中。</h2>
  <div id="div7"></div>
  <div id="div8"></div>
  <script type="text/javascript">
    
    var arr = [2,88,6,8,3,0,34,72];
	var div7=document.getElementById('div7'),
		div8=document.getElementById('div8');
    var sort = {};
    sort.bubbleSort = function (arr) {
        if (arr.length <= 1) {
            return arr;
        }
        //i表示比较的轮数
        for (var i = 0; i < arr.length - 1; i++) {
            //比较i轮，把i个最大数放在数组后面，排数这i个数
            for (var j = 0; j < arr.length - 1 - i; j++) {
                if (arr[j] > arr[j + 1]) {
                    var temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                }
            }
            //console.log("第" + i + "轮:arr=[" + arr + "]");
			div7.innerHTML+=("<p> 第" + i + "轮:arr=[" + arr + "] </p>");
        }
    };
    sort.bubbleSort(arr);
	//console.log(arr);
	div8.innerHTML+=("<p>"+ arr +"</p>");
    第0轮:arr=[2,6,8,3,0,34,72,88]
    第1轮:arr=[2,6,3,0,8,34,72,88]
    第2轮:arr=[2,3,0,6,8,34,72,88]
    第3轮:arr=[2,0,3,6,8,34,72,88]
	第4轮:arr=[0,2,3,6,8,34,72,88]
	第5轮:arr=[0,2,3,6,8,34,72,88]
	第6轮:arr=[0,2,3,6,8,34,72,88]
	[0, 2, 3, 6, 8, 34, 72, 88]
  </script>
</div>

<div class="div1">
  <h2>
    5、希尔排序<br />
   原理：先将整个待排元素序列分割成若干个子序列（由相隔某个"增量"的元素组成的）分别进行直接插入排序，然后依次缩减增量再进行排序，待整个序列中的元素基本有序
   （增量足够小）时，再对全体元素进行一次直接插入排序。
  </h2>
  <div id="div9"></div>
  <script type="text/javascript">
    var arr = [2,88,6,8,3,0,34,72],len = arr.length;
    for (var fraction = Math.floor(len / 2); fraction > 0; fraction = Math.floor(fraction / 2)) {
        for (var i = fraction; i < len; i++) {
            for (var j = i - fraction; j >= 0 && arr[j] > arr[fraction + j]; j -= fraction) {
                var temp = arr[j];
                arr[j] = arr[fraction + j];
                arr[fraction + j] = temp;
            }
        }
    }
    //console.log(arr);
	div9.innerHTML+=("<p>"+ arr +"</p>");
  </script>
</div>
</body>
</html>